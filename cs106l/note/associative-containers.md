# 关联容器
## 复习

`vector`的下标是不带边界检查的，而`at`则会抛出异常。

## 关联容器
`map` `set`和无序版本的`map`和`set`.

有序版本的需要类型实现`<`以便比较来排序。
当元素插入有序的关联容器后会自动排序。


## iterator
五个不同类型的迭代器。
1. 输入
2. 输出
3. 前向
4. 双向
5. 随机

所有的迭代器都可以进行自增，和`==` `!=`的比较

输入和输出其实就是对迭代器进行读写，解引用即可。

前向的迭代器可以进行自增.`forward_list`的迭代器就是这种，单链表所以只能一个方向。

双向迭代器可以还可以进行自减。`map` `set` `list`的迭代器都是双向迭代器。

随机的迭代器就厉害了，他可以进行随意数量的加减，可以随机访问，只有`vector` `deque` 和`string` 以及裸指针可以这样。


## 容器的删除
容器的删除会导致迭代器的失效。
对于`vector`来说，所有迭代器在删除元素后都会失效

`deque`一样，除非删除开头或最后的元素。

`list/set/map`迭代器不会因为删除而失效。



```cpp
std::vector<int> vec{1, 2, 3, 4, 5, 6, 7, 1, 1, 1, 1, 1};
for (auto iter = vec.begin(); iter != vec.end(); ) {
  if (*iter == 1) {
    iter = vec.erase(iter);
  }else{
    ++iter;
  }
};
```
因此在我们删除元素后，可以接受`erase`的返回值，在删除后更新迭代器。

但是上述代码遍历删除的方式很慢，我们可以使用`erase(begin,end)`来实现。


