# raii
试想以下代码
```cpp
vector<int> vec = new vector<int>(10,0);
{
// some code 
}

delete vec;

```
如果在`new`和`delete`之间出现了异常，那么`new`的内存将不会被释放，我们需要`trycatch`来进行回收。


##  异常的安全等级
`nothrow`的保证:不会抛异常的函数，比如析构，交换，移动构造等
强异常安全:异常后会回滚操作，保证一致性
基本异常安全保证:异常后程序可以继续执行
没有异常安全保证:内存泄漏等。


## raii
`Resource Acquisition Is Initialization`
获取资源即初始化。

`raii`的含义
1. 所有资源都在构造中获取
2. 所有资源都在析构中释放


典型的例子
```cpp
void Foo(database){
  database.lock();
  // 如果有这段代码发生异常
  // 控制流会被转移
  // 下面释放锁的代码可能执行不到
  // 则锁永远不被释放
  database.unlock();
}
```
上面的例子，如果中间代码发生异常，捕获的话，我们可以在异常处理中释放锁。但如果像上面一样没有捕获，控制流就会传递给调用该函数的代码，此时栈上的数据都会被清空，而我们的锁却永远也不会被释放了。

应该改成
```cpp
void Foo(database,lock){
  lock_guard<mutex>(lock);
  // 操作
}
// 当我们创建的锁变量离开作用域
// 会自动释放锁
```
这样，当抛出异常时，释放栈，会导致`lock_guard`的析构函数被执行，进而解锁。


同时我们要尽量避免`new`和`delete`，转而使用智能指针等方法自动管理内存。

## 智能指针
`unique_ptr`：一个`unique_ptr`指向一个对象，指针被销毁，对象就会被析构
由于只能一对一，因此不允许复制。

与之相反`shared_ptr`允许多个指针指向同一个对象，利用引用计数的方式管理资源，当最后一个指针被销毁时，释放对应的对象。


### 创建智能指针
`new`和`make_shared<T>()`哪个好？


1. 函数参数求值优先于函数
2. 函数是原子的
3. 参数可能影响其它参数
