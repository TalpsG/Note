# 表达式
## 基本概念
- 运算的对象可以被提升等级，比如`char`和`int`进行加法
- 重载运算符，类可以自定义运算符的含义。
- 左值右值：左值是可以修改内容的，右值只能使用他的值
  - 赋值等号左侧需要左值
  - 取地址符作用于左值，返回右值
  - 解引用，下标，迭代器解引用的结果都是左值
  - 自曾自减运算符作用于左值，结果也是左值

`decltype`作用于左值表达式则结果为引用。
```c
decltype(*p) a = b; // a为引用
decltype(&p) c;     // c为二级指针
```


### 求值顺序
`int i = foo() * bar();`
这里并没有规定函数的求值顺序，因此`foo` `bar`谁都可能先求值。

只有四种运算符规定了求值顺序
1. `&&`
2. `||`
3. `?:`
4. `,`逗号

算数运算符的运算对象和结果都是右值.



## 赋值运算符
赋值运算符左侧必须是一个可修改的左值。

可以使用花括号的列表初始化进行赋值
`int a = {3.14}`



## 位运算符
## sizeof
`sizeof`返回对象的结果类型大小。
且`sizeof`不会计算对象的值，因此`sizeof(*(int*)(0))`在此处也是合法的，因为空指针不会被解引用。


## 逗号
`exp1,exp2;`对于逗号运算符，`exp1`的结果会被丢弃，整个表达式的结果是`exp2`

## 类型转换
类型转换是发生在运算符进行运算时候的，比如`int a = double * int + float;`
其中`int`在运算中被转成了`double`，后面的`float`在相加的时候也被专成了`double`
算数转换：两个对象中窄的对象会被转换成宽的对象的类型
整型提升：对于小于`int`的类型来说，只要能被放在`int`里，在运算是就会被提升成`int`
无符号运算类型：往宽了转


### 其他隐式转换

数组转化成指针:
数组被`decltype`，`取地址`，`sizeof`和`typeid`的时候不会被转换成指针。

### 显式转换
`cast-name<type>(expr);`
`cast-name`是转换的名称，`type`是目标类型，如果`type`是引用，则返回左值。

#### static_cast
`static_cast`就是普通的强转，一般用于大转小，忽略精度的丢失，原数据不能有底层`const`

#### const_cast
`const_cast`可以改变底层`const`，比如: 
```c
const char *pc;
char *p = const_cast<char*>(pc);
```
这样一来`p`就没有了底层`const`

常用于函数重载


#### reinterpret_cast
`reinterpret_cast`是改变变量解释方式的转换，比如`int*`->`char*`就需要使用`reinterpret_cast`.
