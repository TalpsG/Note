# 拷贝控制

学习控制类型拷贝，赋值，移动或销毁的行为。
拷贝构造函数，移动构造函数，拷贝赋值运算符，移动赋值运算符，析构函数。

在定义一个类的时候，我们显式或者隐式的指定类对象的**拷贝，移动，赋值，销毁的行为**，一个类通过定义五种成员函数来控制这些操作
- 拷贝构造函数 
- 移动构造
  - 这两个函数定义了使用相同类型的其他对象初始化本对象的行为
- 拷贝赋值函数
- 移动赋值
  - 这两个函数定义了用相同类型对象赋值给其他对象的行为
- 析构函数
  - 析构函数定义了销毁对象时的行为

编译器会自动定义缺失的操作，但是对于某些类，默认定义是错误的。
## 拷贝赋值与销毁

### 拷贝构造
构造函数的第一个参数是自身类型的引用，且其他参数也都有默认值，则该构造函数为拷贝构造。

拷贝构造在某些情况会被隐式使用，因此不应该是`explicit`的。
一般情况下，默认的拷贝构造会一个一个成员的拷贝到新对象中，对于类成员，调用其拷贝构造，内置类型直接拷贝。

拷贝初始化通常使用拷贝构造来完成，但是也有例外，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数。

拷贝初始化发生的情况
- 使用`=`初始化对象
- 非引用类型的参数传递
- 返回非引用类型的对象
- 列表初始化数组元素或聚类中的成员
- 容器的`insert`或`push`是拷贝初始化，与之相对的`emplace`都是直接初始化

如果拷贝构造的第一个参数不是引用，则会发生：调用拷贝构造要传参，参数值传递要调用拷贝构造，如此循环。

编译器也可以绕过拷贝或移动构造函数
对于`string nullbook = "1233r54ewf"`，编译器被允许直接改写为
`string nullbook("1233r54ewf")`。
但是即使编译器跳过了拷贝或移动构造函数，拷贝或移动构造函数也必须是可以访问的(比如不能为`private`)

#### 拷贝赋值运算符 也就是= 

**注意使用`=`初始化对象不算拷贝赋值，而是拷贝构造**
重载赋值运算符
`T &operator=(const T&);`


重载的赋值运算符通常返回一个指向左侧运算对象的引用，标准库也通常要求保存在容器中的类型要有赋值运算符。

与拷贝构造类似，拷贝赋值运算符如果没有被重载，编译器会自动生成一个。行为就是对每个非`static`成员进行拷贝赋值



### 析构函数
构造函数初始化非`static`成员，和一些其他的工作。析构函数释放对象使用的资源，销毁非`static`的成员。

析构函数签名 `~T();` 没有参数，返回值，也不能被重载，一个类就一个。

类似构造函数有一个初始化部分和函数体，析构函数也有一个函数提和析构部分。

在构造函数中，初始化先于函数体，先定义的成员先初始化。
析构函数中，先执行函数体，然后销毁成员，按照初始化的逆序销毁。
析构函数中没有类似构造函数初始化列表的东西，成员销毁完全依赖成员的类型。类成员调用自己的析构，内置类型什么也不做。**指针不会在被销毁时执行`delete`.

对象被销毁时会调用析构函数，对象被销毁的情况有
- 变量离开作用域时被销毁
- 对象被销毁时，成员被销毁
- 容器被销毁
- `delete`动态分配的内存
- 临时对象在表达式结束就被销毁


析构函数的函数体不直接销毁成员，函数体之后的隐式的析构部分才销毁成员。


#### 三五法则
三个函数控制类的拷贝:拷贝构造，拷贝赋值，析构函数
新标准下还可以定义移动构造和移动赋值。 


##### 需要析构函数的类也需要拷贝和赋值操作
如果一个类需要析构函数，那么大概率也需要拷贝构造和拷贝赋值

##### 需要拷贝就需要赋值，反之亦然
比如当我们定义的每个类中都有一个独一无二的`id`时，我们的拷贝和赋值操作就不能逐个进行拷贝了，需要自己编写拷贝和赋值。


#### default
可以使用`=default`来显式的要求编译器生成默认版本的拷贝控制成员
```cpp
class T{
  Sales_data() = default;
  Sales_data(Sales_data &) = default;
  Sales_data &operator=(Sales_data &) = default;
  ~Sales_data() = default;
};

```

#### 阻止拷贝
新标准下我们可以定义拷贝赋值和拷贝构造为`=delete`来组织拷贝，这样的函数虽然声明了，但是不能调用他们。
```cpp
struct T{
  T()= default;
  T(const T&) = delete; // 阻止拷贝构造
  T &operator=(const T&) = delete; // 阻止赋值
}

```

与`default`不同的是，`delete`可以对任何函数使用。
但是我们不能删除析构函数，因为析构函数删除了我们不能定义该类型的变量或创建临时对象了。

如果析构被删除了我们不能创建临时的变量，但是可以`new`对象出来，只是不能`delete`了。

##### 合成的拷贝控制成员可能是delete的
编译器生成的合成拷贝控制成员可能是`delete`的
- 类中有成员的析构函数是`delete`的或`private`的,则类的析构函数是`delete`
- 类内有成员的拷贝构造是`delete`或`private`则类的拷贝构造为`delete`
- 如果类成员的析构函数是`delete`或`private`的，则类的合成拷贝构造函数也是删除的
- 类的成员拷贝赋值运算符是删除的或不可访问的，或者类内由`const`或引用成员，则类的合成拷贝赋值运算符是删除的
- 类的成员的析构是删除的或不可访问的，或是类内有引用，且没有类内初始化器，或是类内有`const`成员，且没有类内初始化，且器类型没有显式定义默认构造函数，则该类的默认构造函数为删除的


这些规则本质上的意思就是:**一个类内成员如果不能默认构造，拷贝，赋值，或销毁，则对应的成员函数将被定义为删除**

`const`成员或引用成员只能在构造的初始化部分进行赋值，因此如果类内有`const`或引用成员，编译器无法生成默认的构造函数,拷贝构造也是如此。

析构被删除或无法访问会导致拷贝构造和默认构造被定义为删除，是因为不这样可能会创建出无法删除的对象。

在新标准之前是通过`private`来进行拷贝控制的，对想要阻止的拷贝成员函数声明成`private`,且不定义，这样用户代码的拷贝操作在编译期就被发现，而友元函数或类内的拷贝操作会导致链接发生错误。


## 拷贝控制和资源管理
通过拷贝控制可以定义类的拷贝行为像是值或者指针。
### 像值的类
- 拷贝行为要进行深拷贝,包括拷贝构造和拷贝运算符，拷贝指针指向的内容
- 析构函数内要释放指针


**注意拷贝赋值运算符内的行为组合了析构和拷贝构造，先要释放指针的内容，再新分配内容给指针。**

注意拷贝赋值中的销毁操作
```cpp
HasPtr &operator=(HasPtr &hp) {
  a = hp.a;
  delete sp;
  sp = new std::string(*hp.sp);
  return *this;
}
```
上面代码中如果传入的引用是**自引用**，则会销毁`sp`所指对象，新建对象将是未定义的行为，因此需要把代码改为下面的样子

```cpp
HasPtr &operator=(HasPtr &hp) {
  a = hp.a;
  std::string *nw = new std::string(*hp.sp);
  delete sp;
  sp = nw;
  return *this;
}
```
先新分配资源,然后在销毁旧的资源。

### 像指针的类
需要引用计数记录类中指针指向资源有多少对象共享。

- 初始化时构造函数要创建引用计数
- 拷贝构造不分配新的计数器，而是拷贝计数器，拷贝构造递增共享的计数器。
- 析构函数递减计数器，如果计数器为0,则析构函数释放对应的对象
- 拷贝赋值运算符递增右侧的计数器，递减左侧的计数器，计数器为0时也需要释放对应对象


这里有一个难点，就是计数器存放在哪里，当多个对象共享同一资源时，需要每个对象都能访问到所有的计数器，因为赋值或新建对象操作会修改所有对象的计数器.

有一种方法是将计数器分配在堆区中，然后每个对象内有一个指针指向计数器。





## 交换操作
管理资源的类通常会定义一个`swap`函数，用来交换对象内数据，对于需要排序的对象，`swap`很重要。


可以在赋值运算符中使用`swap`
```cpp
Foo &operator=(Foo f){
  swap(*this,f);
  return *this;
}
```
由于`f`不是引用，交换并不会影响到实参。


`swap`对于内置类型会调用`std::swap`，对于例如`string`的类应该有类似的`swap`，自定义类也应该有`swap`用于重载。
只有当元素个数较多时才会调用自定义的`swap`。


## 动态内存管理类
有些自定义类需要自己进行内存分配，而不使用标准库的容器来保存数据。

比如实现一个存放`string`的类似`vector`的类。
需要预先分配内存以便存入数据，添加数据时会检查空间，如果内存不够会新分配内存然后移动数据。



### 移动构造函数和std::move
移动构造函数的大致思想就是浅拷贝，而非深拷贝。例如`string`的移动构造函数大致就是只拷贝了`string`内指向字符串的指针，而并未拷贝实际的字符串。

`move`函数表示希望使用移动构造函数，如果不使用`move`，则拷贝会使用拷贝构造。，
`std::move`可以让使新对象调用移动构造，老对象内的内容被移动到新对象后就被释放了.

```cpp
string s1 = "apple";
string s2(std::move(s1));
cout << s1<<'\n';
//  空
cout << s2 <<'\n';
// apple
```
上述代码展示了`move`的大致使用，将其传入构造函数就可以调用移动构造，构造完成后`move`内的对象被释放


`for_each`中前两个参数应该是迭代器或者指针，第三个参数是函数或者`lambda`表达式，**注意`lambda`要访问类内成员需要捕获`this`，还要注意`lambda`参数的类型**


## 对象移动
新标准中的一个特性就是可以移动而非拷贝对象。
在某些情况下移动而不是拷贝是因为有些类存在不能被共享的资源，比如`IO`类和`unique`指针。


### 右值引用 &&

左值和右值是表达式的属性，左值代表对象本身，而右值代表的仅仅是对象的值。
左值有生命周期，而右值出了表达式就没了。
左值引用其实就是对象的别名，右值引用也一样。

返回引用的函数，以及下标，赋值，解引用，前置递增递减等操作返回的都是左值。
而返回非引用的函数以及表达式，后置递增递减运算符都是右值.

左值引用不能绑定右值，但是`const`左值引用可以绑定右值

左值有持久的状态，也就是有其自己的生命周期。而右值不是字面值就是表达式生成的临时对象。

右值引用智能绑定到临时对象上，因此右值引用的对象是要被销毁的且没有其他用户的对象。

因此右值引用可以接管临时对象的资源。

因此右值引用不能绑定变量，因为变量是左值，不是临时的。

#### move
可以通过`move`让右值引用绑定到左值上。

**`move`的作用也仅仅是让左值转换为右值，可以让别人接管这个对象而已**

由于我们不知道对象在被`move`后哪些数据发生了改变，所以`move`后就不要再使用原来的对象了，因为这个对象的数据已经被别人接管了。


我们可以借助`move`来重载构造函数，实现移动构造函数。
移动构造函数相比拷贝构造性能往往要更好一些，因为指针的改变相比拷贝的开销要小一些。

只有右值临时对象可以初始化右值引用，右值引用一旦初始化后，就和左值没有什么区别了。

**所有变量都是左值，包括右值引用，都可以直接修改。因而不能用右值引用来初始化右值引用。**
```cpp
int &&a = 5;
int &&b = a; // 非法操作
```

**一句话，`move`将左值转换为右值，也就是把将会销毁的对象的所有权转移，使其生命周期延长**

### 移动构造和移动赋值运算符
移动构造的第一个参数必须是本类类型的**右值引用**,在构造内完成资源的移动，必须能保证移动后的原对象还可以被销毁，即使原数据被转移。

移动构造通常不抛出异常，我们把`noexcept`放在构造的初始化列表之前来表示代码编写者承诺函数内部会抛出异常。

为什么移动构造不抛出异常？
因为移动构造在函数内抛出异常可能会导致两个对象的状态不一致，移动一半时出了错，很难去恢复。
而拷贝构造可以抛出异常是因为拷贝构造出现异常不会影响原来的对象。


#### 移动后原对象必须可析构
我们必须保证`move`后的原对象还是有效的，我们可以对他进行赋值析构等操作，只要我们不依赖原对象`move`后的值就可以了。


#### 合成的移动操作
与拷贝构造和拷贝赋值一样，移动构造和移动赋值也可以被编译器合成，但是条件却不相同。

只有当一个类没有**声明**任何的拷贝控制成员，且每个非`static`成员都可以移动时，编译器才会为他合成移动构造或移动赋值。

移动操作永远不会隐式的定义为删除，但是拷贝操作会隐式的定义为删除，因为拷贝构造会受到类内成员的拷贝构造和析构影响。

当我们显式的要求编译器生成`default`的移动构造，且有成员不能被移动时，编译器生成的`default`的移动构造是删除的。

- 有成员定义了自己的拷贝构造且未定义移动构造时，类的移动构造是删除的. 移动赋值类似
- 编译器没有为成员生成移动构造时，类的移动构造是删除的，移动赋值类似。
- 类成员的移动**操作**定义为删除的或不可访问的，则移动操作被定义为删除的
- 类的析构函数是删除的或不可访问的，则移动构造是删除的
- 类内有成员是`const`或是引用，则移动赋值被定义为是删除的。


当类定义了自己的移动构造和或者移动赋值时，该类合成的拷贝构造和拷贝赋值会被定义为删除

**其实就是，定义了拷贝操作，则移动操作不会自动合成。但是定义了移动操作而没定义拷贝，则拷贝是默认删除的**
#### 参数的匹配
```cpp
T &T::operator=(T&);
T t1,t2;
t1 = t2; // 拷贝赋值
T get();
v2 = get(); 
// 由于拷贝赋值的参数是左值引用,而移动赋值的参数精确的匹配了右值，因此此处调用移动赋值。

```
上述例子演示了拷贝操作和移动操作的参数匹配,`const`的左值引用是可以和右值引用转换的,这样就可以实现函数既可以传入左值也可以传入右值了。


如果一个类定义了拷贝操作，则移动操作不会被编译器生成，这样即使调用`move`获取右值来传入构造函数也会调用拷贝构造。

##### 关于移动赋值的trick
```cpp
class T{
public:
  T(T&&)noexcept;
  T(const T&);
  HasPtr& operator=(T t){
    swap(*this,t);
    return *this;
  }
}
```
上述代码中的赋值运算符中的参数不带引用，这样传入参数时
- 实参为左值，则调用拷贝构造，实现了对应的含义
- 实参为右值，则调用移动构造，也实现了对应含义,此后不应该再使用传入的实参。

这个重载的赋值实现了两种功能.

一般来说，只要类定义了拷贝操作，就应该定义五个操作:
1. 拷贝构造
2. 拷贝赋值
3. 移动构造
4. 移动赋值
5. 析构函数


#### 移动迭代器
有时我们使用`allocator`分配的内存后，想要拷贝一些元素到该内存处。如果使用`uninitialized_copy`会比循环加构造更为简单，但是无法将元素拷贝到没有构造的内存中来。

新的标准库中有移动迭代器。一般的迭代器解引用返回左值，而移动迭代器返回右值。
`make_move_iterator`可以将一个普通迭代器转换为移动迭代器。

标准库不保证算法适用移动迭代器，因此，只有在确信用户不会在访问对象后才使用移动迭代器。



### 13.50 习题
`unique_ptr<T> clone(){return unique_ptr<T>(new T());}`
上面的代码可以拷贝`unique_ptr`的原因是他即将被销毁了，触发了移动构造。



### 一些需要注意的点
1. 参数值传递会使用拷贝构造创建形参
2. 成员的拷贝构造无法使用会导致合成的类的拷贝构造被删除
3. 成员的拷贝赋值无法使用或者有`const`成员，会导致合成的类的拷贝赋值被删除
4. 成员的析构函数无法使用会导致合成的类的拷贝构造以及析构函数被删除
5. 拷贝操作会导致不合成移动操作
6. 移动操作会导致合成的拷贝操作被删除


### 右值引用和成员函数

成员函数可以同时提供拷贝和移动两个版本.
一个版本的参数是`const`左值引用，另一个是`non-const`的右值引用
右值引用重载过的函数，函数内的形参实际上也就是将实参的所有权转移了过来，因此如果函数内想要调用其他右值引用重载的函数，还需要`move`继续传递所有权。


在旧标准中 `s1+s2 = "wow!"`是合法的，我们可以给右值来赋值。新标准中仍然可以这样，但是我们也可以有办法阻止这种用法。


在自定义类中我们可以在成员函数函数后面加一个`&`或`&&`来限定其**只能由左值或右值来调用该函数,运算符本身也是函数，因此实现了阻止右值调用赋值的操作。**


函数也可以被`const`和`&`同时修饰
`int &T::bar()const &;`
此时，返回的


#### 重载和引用
成员函数的引用限定符也可以重载成员函数。

如果一个成员函数有引用限定符号，则具有相同参数列表的成员函数都必须要有引用限定符。

即使参数传入右值引用，想要在参数内调用其他类的右值引用重载的函数，还是需要`move`来包裹参数传入函数。


```cpp
T T::sorted()const &{
  T ret(*this);
  return ret.sorted();
}
```
上述代码由于`ret`是左值，导致返回时调用自身，形成死循环，正确的使用方法是函数体内直接`return Foo(*this).sorted();`这样临时变量是右值，右值不可以调用限定左值引用的`sorted`避免了死循环






















































