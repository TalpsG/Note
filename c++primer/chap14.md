# 重载运算和类型转换

运算符就是类具有特殊名字的函数。
重载的运算符的参数要和运算符作用的对象一样多。

除了重载括号`()`，其他的重载运算符不能有默认实参。

运算符函数是成员函数，则`this`会隐式的绑定到左侧的运算对象上，因此成员运算符的参数数量会比运算符的运算对象少一个。

除了`::` `.*` `.` `? :`，其他的运算符包括`new`和`delete`,`[]`,`()`,`->`,`->*`都可以被重载


某些运算符不应该被重载:
由于重载后的运算符本质上是函数调用，而参数的求值顺序有时无法和运算符的求值顺序相同，因此此类的符号不建议重载，比如`&&`,`||`以及`,`

重载运算符的语义应该和使用内置类型的运算符一样。

- 类有类似`io`的操作，移位运算符应该被重载
- 一个操作符被重载了，相关的也应该被重载比如`<`和`>=`,`!=`和`==`
- 重载后的运算符返回值应该与内置的一样

运算符作为成员函数还是非成员函数？

- `=` `[]` `()` `->`这几个必须是成员
- 复合赋值运算符一般是成员,类似`+=`
- 改变对象状态的运算符或与类型关系密切的，应该是成员，比如 解引用，递增递减
- 具有对称性的运算符，应该是非成员的，比如大于小于，等于不等于,加减等

如果程序员向提供含有类对象的混合类型的运算符，则运算符必须是非成员函数。

## 输入输出运算符
输入输出运算符`<< >>`必须是非成员函数,否则调用运算符的就变成了类对象，调用的代码也会变成`t1 << cout `。

## 算术和关系运算符
没什么好说的

## 关系运算符
由于关联容器和一些算法会用到`<`，因此定义`<`会比较有用。

## 赋值运算符
除了之前学习到的拷贝赋值和移动赋值，我们还可以定义其他的赋值操作

`StrVec &operator=(initializer_list<string>);`
通过重载成员赋值运算符，可以用不同类型的对象给本类对象赋值。

复合赋值运算符类似，也建议定义在类内。

## 下标运算符
下标运算符必须是成员函数。
下标返回的是元素的引用。 
为了能让`const`对象也能调用我们可以重载下标运算符，实现`const`成员函数，返回的`const`引用，这样既实现了下标，也保证了不能对下标返回值赋值。

## 递增递减运算符
前置返回引用，后置返回值。
### 前置递增递减
`T &T::operator++();`
前置运算符需要检查递增操作是否安全，可能会抛出异常。

### 后置
同时定义前置后置需要解决一个问题，由于符号相同，普通的重载无法区分前置还是后置。
为了解决这个问题，后置的运算符接受一个`int`类型的参数，但是不使用，借以来区分前置后置。
`T &T::operator++(int);`


## 成员访问符
`->`必须是成员，而`*`也通常是成员。

```cpp
class T{
public:
  string &operator*()const{
    auto p = check(curr);
    return (*p)[curr];
  }
  string *operator->()const{
    return & this->operator*();
  }
};

```
重载的箭头不需要参数，返回值必须是指针。

箭头的语义是这样的
`p->mem()`的语义只能是两种
1. `(*p).mem`
2. `p.operator()->mem`

对于第一个而言很好实现，只需要重载后返回原对象引用即可
对于箭头而言，我们要确定返回的对象，因为箭头后的代码是返回的对象调用的。
`t1->at();`如果`t1`是上面`T`类型的对象，则`t1->`返回的就是`string`指针


## 函数调用运算符

```cpp
struct absInt{
  int operator()(int val){
    return val < 0?-val:val;
  }
};
```
这个类重载了函数运算符然后就可以被调用了，类似函数调用一样。
在泛型算法中常常使用函数对象作为参数
`for_each(a.begin(),a.end(),printObj("cerr",'\n'));`
如果`printObj`是一个对象的构造函数，则生成一个临时对象，该类重载过函数调用运算符的话，就会对每个`a`中的元素调用这个对象。


### lambda是函数对象
我们编写的`lambda`表达式会生成一个匿名的类，这个类只有一个函数调用成员。
默认情况下`lambda`无法修改其捕获的变量，因此对象内的函数调用成员是`const`的。

#### lambda 捕获的行为
当`lambda`捕获引用时，用户程序来保证引用的对象在`lambda`调用时仍然存在，因此不需要`lambda`保存到他的函数对象内。

而捕获值时，函数对象内会为每个捕获值创建对应的成员。

`lambda`产生的类不包含默认的构造，赋值运算符，以及默认的析构函数，而默认的拷贝构造和移动构造则由捕获的成员决定，成员如果都有拷贝构造和析构，则有拷贝构造


### 标准库的函数对象
标准库利用模板定义了许多函数对象。
比如`plus<T>`可以生成一个对象，调用该对象可执行`T`的`+`操作。

### 可调用对象和函数
不同的可调用对象有着不同的类型，但是他们可能共享相同的调用形式`int(int,int)`.
对于相同的调用形式，我们有时会当作一个类型处理。
比如多个不同命的函数都是`int(int,int)`这种形式的。


我们可以通过函数表的方式将这些可调用对象组织到一起，在通过函数名来调用
`map<string,int(int,int)>`
我们可以添加函数到这个函数表里，但是不可以添加`lambda`到函数表里，因为`lambda`是类类型的，而非函数类型的。

#### 标准库function类型
可以使用名为`function`的标准库类型解决上述问题
`function<T> f(obj);`
其中`T`是调用形式(类似`int(int,int)`)，而非类型，填入的对象的调用形式要与`T`相同。
`function`对象内有属性指出了返回类型，参数类型等信息。

至此我们需要把`map`改为`map<string,function<int(int,int)>>`,然后向内添加`function`类型的对象即可。

重载的函数由于重名不能直接存入`function`对象中，解决方法有
- 使用一个函数指针，指向要存入`function`的函数
- 或者使用`lambda`进行一层包裹也可以。
```cpp
void foo();
void foo(int);
void (*p)() = foo;
function<void(void)> f1(p);
function<void(void)> f1([]{foo();});
```

## 重载 类型转换和运算符
类型转换运算符`operator type() const;`
应该定义为`const`成员，没有返回值，没有参数。

```cpp
class T{
public:
  operator int() const{ return val;}
private:
  size_t val;
}
```
编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义的类型转换可以执行在标准的内置类型转换之前或之后。
`double res = t1 + 4;`中,`t1`可以被隐式

自定义类一般不会提供类型转换，如果类型转换发生用户大都会觉得比较奇怪，并不会对编码产生帮助。但是有一个例外，对`bool`类型的转换。

但是向`bool`的隐式转换可能会出问题
`cin << i;` 由于`cin`可以隐式转换成`bool`，该表达式的意思就转换为`bool`变量左移`i`位，我们需要避免这样的操作。

可以在重载类型转换的函数前加一个`explicit`，使得该类型转换不会隐式发生。

不过即使是`explicit`在特定情况下也会隐式转换，当表达式被用作条件时。这符合我们的期望，当我们将对象放在`if` `while`以及逻辑表达式中时，我们期望他转换称`bool`类型

**也可以重载了类似`operator const int();`的转换，这样的转换结果是转换称`const int`值。

### 避免二义性的转换
当类中有多个类型转换时，要确保类类型到目标类型只存在一种转换方式。

有两种情况下可能发生多重转换路径
1. 两个类提供了相同的类型转换，`A`提供了接受`B`的构造函数，而`B`又定义了到`A`的类型转换。
2. 类定义了多个转换规则，且转换到的类型之间也可以转换。比如算术运算符。

```cpp
struct B;
struct A{
  A(const B&);
}
struct B{
  operator A() const;
}
A f(const A&);
B b;
A a = f(b);
// 此处发生二义性
// f内到底是强转b还是用b构造一个新的A？
```
面对上面代码中的问题，我们可以显式的调用转换来避免二义性
`A a = f(A(b));` 或`A a = f(b.operator A());`


转换目标为内置类型的多重转换
```cpp
struct A{
  A(int = 0);
  A(double);
  operator int() const;
  operator double()const;
}
void f2(long double);
A a;
f2(a);
// 此处发生二义性，a到底要转换成double还是int 

long lg;
A a2(lg);
// 此处也发生二义性，到底要调用哪个构造函数

```

### tips
1. 不要为两个类执行相同的类型转换
2. 避免内置算术类型转换
3. 除了到`bool`的转换，尽量避免定义其他的类型转换

### 类型转换顺序
1. 不转换
2. `const`转换
3. 提升
4. 算术或指针转换
5. 类转换
