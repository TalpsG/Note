# 函数
## 参数
```c
void swap(int &a,int &b){
  int temp = a;
  a = b;
  b = temp;
}

```
可以传引用了，就别用指针了。而且引用传入可以避免对参数的拷贝，当无需修改实参内容时，传入`const`引用即可。

`void foo(const std::string &str1)`


我们也可以利用引用参数来充当返回值，在函数内部修改对应的引用。

**函数参数的顶层`const`是无意义的，因为没有`const`也不能修改实参。
因此对于同名函数来说，顶层`const`修饰的参数等于没有`const`。



### 数组做参数
数组做参数会被转换为指针，因此需要一些手段记录数组的长度。
1. 类似迭代器，使用`begin` `end`传入指针
2. 在数组末尾放个哨兵
3. 传入一个长度参数

不过我们也可以定义参数为数组的引用，这样就可以修改数组元素了。
`void foo(int (&arr)[10])`,不过这样就限制了数组的大小，不等于参数数组大小是进不来的。


多维数组
`void foo(int matrix[][10],int rowsize)`


### 可变参数
`initializer_list`是一个标准库类型，表示特定类型的值的数组
操作如下
```c
initializer_list<T> lst{a,b,c,d};
lst.size();
lst.begin();
lst.end();
```
`initializer_list`中的对象都是常量，无法修改。  

可以将其用在函数参数上，这样就可以传入多个同类型的参数,传递时需要花括号包裹住要给`initializer_list`的参数。
```c
void foo(initializer_list<int> ls);

foo({1,2,3,4,5});
```


#### 省略符形参
为了方便使用c代码而设置的，省略符形参会使编辑器不在检查之后的参数类型.


## 返回类型

返回值则会进行拷贝，返回引用不会进行拷贝。
不要返回局部对象的引用和指针。

函数的返回类型决定了函数调用是否是左值，返回引用则得到左值，其他是右值。


### 列表初始化返回值
```c
vector<int> foo(){
  return {1,2,3,4}
}
```
如果返回值是内置类型，则列表只能有一个值。
其实列表初始化返回值就是一个语法糖而已，把返回值初始化放到了列表初始化里。



### 返回数组指针
可以借助类型别名来简化函数返回数组指针
```c
using arr = int[10];
arr *func(int i);
// 等价于
int (*func (int i))[10];
```
也可以使用c++11的新的方式，尾置返回类型
`auto func(int i)->int(*)[10];`


如果知道要返回的指针指向的数组，也可以使用`decltype`。

## 函数重载
函数参数列表不同，被称为重载函数


在函数重载时，顶层`const`是被忽略的，也就是单单在函数参数上加顶层`const`是无法实现重载的。

底层`const`是可以实现重载的，因为参数变成了可修改的和不可修改的了。

如果有这样一个函数，`const A &foo(const A &a);`,我们也可以传入非常量的参数，但是得到的引用却是常量。如果我们想要非常量引用，可以这样实现
```c
A &foo(A &a){
  const A &ret = foo(const_cast<const A &>(a));
  // 此处调用的是 常量引用版本的foo
  return const_cast<A&>(ret);
}
```

当匹配重载函数时，如果存在最佳匹配，则调用最佳匹配。如果没有匹配的函数，则报错，出现二义性也会报错。


## 特殊用途语言特性

### 默认实参
`void foo(int a = 80,double b = 2.2,string c = "123")`
此时调用`foo`可以省略尾部参数，这样参数会取默认值。

对函数的声明可以增加默认参数，但是不可以修改
```c
int foo(int a,int b,int c= 0);
int foo(int a,int b=0,int c);
int foo(int a = 0,int b,int c);
```
由于我们可以对函数增加默认参数，所以可以在默认实参中使用表达式，全局变量等。
`int foo(sz = ht(),sz = wd,char = def)` ，当全局变量改变时，函数的默认参数一样会变。


### 内联函数和constexpr函数
内联函数就是让函数在被调用处展开，避免了函数调用的开销。
在函数定义前增加`inline`就可以，不过仅仅是请求编译器内联，决定权仍然属于编译器。

`constexpr`函数指的是用于常量表达式的函数，必须只能有一条`return`。
这种函数的返回值是否是常量有时与参数有关，如果返回值依赖参数，那么参数是常量，则返回值是，否则不是。

**内联和`constexpr`函数应放在头文件内定义**


### 调试帮助
`assert`: 假时终止程序
`NDEBUG`:定义了该宏后`assert`就不在进行检查了，我们可以借助这个宏编写一些`debug`时需要的代码。


## 函数匹配
### 确定候选函数和可行函数
候选函数就是在某个位置可以调用的同名函数。
可行函数就是候选函数中参数能对应上的(数目相同，类型相同或可以转换)

确认完可行函数后，就需要寻找最佳匹配，如果没有最佳匹配则报错。
```c
void foo(int ,int);
void foo(double ,double);
foo(1.1,1); // 该调用是非法的，没有最佳匹配
```

### 实参类型转换
最佳匹配的优先级
1. 精确匹配: 类型相同，或数组函数类型转换到指针类型，或者忽略顶层`const`
2. 函数形参比实参多了底层`const`
3. 类型提升
4. 算数类型转换或指针转换
5. 类类型转换


类型提升和算数类型转换需要格外注意，比如`char`就会被隐式提升为`int`影响重载的调用，而`3.14`字面值既可以转换成`long`也可以转换成`float`，可能造成重载的二义性。


## 函数指针
`bool (*fp)(int,int);`

给函数指针赋值时，使用取地址符和不用是一样的，同样的通过指针调用函数解不解引用也是一样的。

#### 重载函数的指针

```c
void ff(int *);
void ff(unsigned int);
void (*fp)(unsigned int) = ff;
```
重载函数给函数指针赋值时必须精确匹配参数列表。

#### 函数指针形参
`void foo(int a,void func(int a,int b));`和下面的是等价的，函数可以直接当作指针。
`void foo(int a,void (*func)(int a,int b));`


可以使用`decltype`简化函数指针声明等操作，只是`decltype`不会将函数类型转换成指针。


函数在返回值类型处不会自动变成指针，但是在赋值当右值，以及当参数时会自动变成指针


#### 返回函数指针
可以通过`using`等操作简化返回函数指针的代码
```c
using fp = int(*)(int,int);

fp foo(void);
// foo 返回函数指针
int (*foo(void))(int,int);
// 与上面的代码等价，只是没有用别名
```

尾置返回类型:`auto foo()->int(*)(int,int);`


