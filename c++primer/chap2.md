#  变量和内置类型
## 内置类型
与c类似，多了一些
- `wchar_t` 宽字符
- `char16_t`和`char32_t` ，都是unicode字符

计算浮点数时尽量使用`double`，因为`double`和`float`的计算代价相差无几，但是`double`的精度要比`float`高很多


### 类型转换
无符号和有符号之间不要搞混

### 字面常量值

类型都遵循了一个规定: 最小能容纳字面值的类型就是其类型
比如 十进制的数 类型是 `int` `long` `long long`中能容纳下的最小的类型
八进制和十六进制则包含了对应类型的无符号类型。
如果都容纳不下则会报错。

浮点数默认`double`

#### 字符和字符串字面值
类似`C`的字符串

可以指定字面值的类型，通过添加对应的前缀或者后缀


- `L'a'`就是`wchar_t`
- `u`代表unicode16字符
- `U`是unicode32字符
- `u8`仅能用于字符串，代表utf8字符串

#### 数字的后缀
以下后缀用大写也可以，无符号可以在其他后缀之前
- `u` 无符号
- `l` `long`
- `ll` `longlong`
- `f` `float`
- `l` `long double`



## 变量

初始化很重要，初始化不是赋值，而是创建变量的时候给定值。
赋值意味着，消除原来的值，改为新的值。

####  列表初始化
```c
int u = 0;
int u = {0};
int u{0};
int u(0);
```
**cpp11 中花括号初始化变量的到了全面的应用**


当列表初始化如果初始值会丢失信息(例如浮点数初始化整形丢失精度)，则编译器会报错



#### 默认初始化
对于内置类型来说，处于函数之外的变量都会被默认初始化为0，比如全局变量。
而函数内部的变量则不被初始化，初值不定.

对于类来说，其初始化的方式是类实现决定的，大多数类都支持默认初始化。


### 声明和定义
c++支持分离式编译，即多个文件都可以被独立编译，最后再链接到一起。

`extern`用来声明其他文件的变量.
特别的
`extern int i = 5;`也是定义。

### 作用域

嵌套作用域:
当外层中的名字可以被内层使用，或重新定义。
```c
int reused = 42;
int main(){
  int unique = 0;
  int reused = 1; // main内部的reused,而非全局变量
  ::reused = 30;
  return 0;
}
```
可以使用作用域操作符来引用外部的变量,全局作用域名为空。


## 复合类型

有好几种，先讲了两种
1. 引用:分左值和右值，常规指的都是左值
2. 指针


### 引用
```c
int t = 1024;
int &ref = t;
```
引用必须被初始化，所以只定义不赋值的引用是会被报错的。

**引用在汇编层面就是利用指针访问了对应的变量，一个语法糖**

不能定义引用的引用,但是可以嵌套引用，比如
```c
int &a = b;
int &c = a;
```
上述例子中c就绑定到了b上面。


引用的类型要和绑定的对象严格匹配，且不能用字面值或表达式来绑定引用。

### 指针
指针的类型也要严格匹配对象。

空指针: 与c类似，使用`nullptr`,实际上都是0


#### 引用和指针的区别
引用并非是一个对象，而且引用只能访问一个对象。


#### void *
void *的指针不可以解引用

### 复合类型的声明
变量定义包括
1. 数据类型:`int` `long` 这些
2. 声明符: `&` `*`这些


指向指针的引用

`int i = 1 , *p = &1 , *&rp = p;`
上述代码中rp是一个指针类型的引用，实际rp访问的对象是p指针


## const
由于`const`修饰的值不能变，所以`const`对象必须被初始化。


对`const`变量用其他的对象初始化时，不关心其他的对象是否是`const`

```c
int i =5;
const int a = i;
int z = a;
```

默认情况下`const`对象仅在文件内有效

如果想在多个文件间共享`const`变量，必须在定义前加上`extern`


### const引用
`const int &r = i` 不能修改引用的变量值
类似`const int *p = i` 不能修改`p`指向的值。


#### 初始化 const 引用
对`const`引用的初始化可以使用任意表达式作为初值，只要表达式可以转换成引用对象的类型即可。

可以这样的原因是编译器做了如下代码:
```c
double dval = 3.14;
const int &ri = dval;
// const int temp = 3.14;
// const int &ri = temp;
```

`const`引用可能引用一个非`const`对象




### constexpr 常量表达式
在编译期间就可以获得结果，所以字面值属于常量表达式。

通过在声明前加`constexpr`来让编译器检查变量是否是常量表达式。
用函数初始化`constexpr`类型的变量时，函数必须也是`constexpr`类型的。

函数内部的变量位置是会变化的，因此`constexpr`指针不能指向函数内的变量，只能指向`static`或全局变量。

`constexpr`修饰在定义指针的时候只对指针有效
`constexpr int *p = nullptr;`中p为一个常量的指针。

## 类型
### 别名
`typedef`

`using SI = Sales_item;`

```c
typedef char *p;
const p cstr = 0;
```
上述代码里`cstr`实际上是一个不可变指向的指针，因为当`typedef`之后，p的基本类型就变成了指针，`const`修饰的是指针。

### auto

`auto`会忽略顶层`const`而保留底层`const`。

顶层:如果仅有一个`const`，那么这个`const`就是顶层`const`，否则顶层`const`是修饰指针的。
底层:只有一个`const`是没有底层的，底层`const`是指修饰指针指向的数据类型的`const`

需要`auto`是顶层`const`的时候可以显式说明
`const auto f = ci;`

`auto`声明多个变量时，需要多个变量都是一个类型的。


### decltype
自动推断函数返回值以及表达式类型。
`decltype(f())` 推断类型但是不执行`f`函数

`decltype`与`auto`处理`const`的方式不同:
- `decltype`使用变量则返回变量的类型
- 使用引用就返回引用的类型

引用只有在`decltype`这里被当作一个类型，其他情况下都指的是被引用的那个对象



```c
int i = 42, *p = &i,&r = i;
decltype(r+0) b; 
decltype(*p) c;
```

当我们不想获得引用类型时，可以使用表达式来将引用转化成具体的值

**`decltype`对指针解引用获得的结果是引用类型**

**`decltype`对左值返回一个引用，而`(expr)`正是一个左值表达式，因此对所有的`decltype((var))`来说，其返回的类型永远是引用**


`a = b`这种赋值表达式的类型就是引用类型








