# Logging
## why logging
`ext3`中使用的就是Logging

why logging
1. 他可以用于任何一个已知的存储系统的故障恢复中
2. logging作为一种故障恢复机制，在分布式系统中也有应用
3. logging系统本身有意思

ext3就是ext2加上日志。

lec16也主要讲的是ext3和xv6的logging的区别，ext3是如何解决xv6存在的性能问题的。

## xv6 Logging

树状的文件目录，bitmap管理磁盘块,inode和file用来存放文件的元数据。
磁盘中流出一些块用于log，文件的读写过程中，会把磁盘的block放在内存中的磁盘缓存中，写文件的操作就是将磁盘缓存写到日志里，在最后事务提交时将日志的修改同步到磁盘文件中。


### 要点
1. 日志系统的更新具有原子性。
2. 同步日志到磁盘的过程中不可以释放log块，直到全部写完才可以。


xv6的写操作对于每一个磁盘块来说要执行两次，一次是把修改写入磁盘日志块,第二次是写磁盘文件里。


## ext3 fs log format
`ext3`基于的就是课前读的论文，它就是在`ext2`基础上添加了logging层。

ext3中也有bcache,也维护了一些事务的信息
1. 序列号
2. 事务修改的块号，这里的块号是指bcache里的块号，不是物理块号
3. 一系列handle,对应了文件相关的系统调用。


在磁盘上和xv6一样
1. 一个文件系统树
2. bitmap
3. log块


ext3的log块与xv6有些不同。最开始是一个super block， 记录了第一个有效的事务的起始位置和序列号，起始位置就是块号。其他块存放了事务，每个事务包含:
1. 描述符块，记录了修改的块号，类似xv6的日志头
2. 对每个块的更新
3. 事务完成时会commit,有一个commit 块。

ext3里日志层可能有多个事务，commit块之后会跟着下一个事务的描述符块，所以log块会很长，且包含多个事务。

在crash后扫描日志块恢复时，为了区分描述符块，commit块和数据块，描述符块和commit块会以一个magic number开始。

## ext3 如何提高性能
- 异步系统调用，系统调用写磁盘之前就返回了，系统调用只更新内存上的缓存块。
- 多个系统调用打包成一个事务，批量执行
- 并发


### 异步syscall
可以很快的返回系统调用。

异步的结果就是可以可以很快返回，但是实际操作并没有完成。不过这让打包事务变得简单了。

异步导致系统调用返回后，用户仍无法得知磁盘是否已经更新。

unix中有一个fsync的syscall,可以使我们对文件的读写落盘后才会返回。

### 批量执行
ext3 的一个事务中可以有多个syscall。

为什么好？
- 分摊了事务的固定开销
- 某些syscall对磁盘的操作可以合并到一起，比如一个事务中许多syscall对某一块进行读写，那么在这个事务中只要写一次该块就可以了
- 磁盘调度友好，写入连续的磁盘块要比随即写入高效

### 并发

- ext3 支持多个syscall同时执行，在关闭事务前syscall不必等待其他syscall的完成，直接去修改事务中的日志块
- 可以有多个不同状态的事务同时存在
  - 只能有一个事务正在接受系统调用
  - 若干个正在提交到日志的事务
  - 若干个正在向文件系统写数据的事务
  - 若干个正在被释放的事务

ext3 中如果前一个事务还没提交，但是已经关闭，新事务想要访问上一个事务修改的块，则采用copy on write的策略。


## ext3 文件syscall 调用格式
start函数用来开启新事务，并返回一个handle,用来跟踪当前的syscall
当系统调用真正完成时，才可以提交事务，handle就是用来记录事务等待的syscall的。
stop 传入handle告知日志系统，该事务的对应syscall已经完成。

## ext3 事务提交的步骤
1. 阻止新的syscall
2. 等待事务中的syscall完成
3. syscall都完成后证明内存中的磁盘缓存都写上了，开启新事务，接受syscall到新事务里
4. 更新描述符块内的修改过的块号
5. 把内存中的块缓存写入磁盘日志块中
6. 等
7. 磁盘日志块更新完毕后写入commit块
8. 等commit块写完
9. 更新日志块到文件系统中
10. 释放日志块空间,修改superblock里的起始块号


## 恢复的过程

crash后，恢复程序读取superblock,找到日志起始位置
开始进行恢复，扫描日志，提交日志到磁盘。

当扫描到最后一个日志之后，计算机如何意识到这个日志就是最后一个日志呢。在往下扫描，后面的块里就是随机的数据了。如果下一块的起始数据是magicnumber则认为下一个块是个描述符块。(如果数据块也是magicnumber起始的，则会将起始的magicnumber替换为0,并在描述符块中做一个标记)

因此当commit块之后不是描述符块的时候，或者描述符块之后没有commit块时，日志扫描完了。

## 为什么新的事务要等待上一个事务的系统调用完成？

因为老的syscall没完成的话，缓存是没更新的，并发的对缓存进行操作而不加以限制是错误的。

## 总结
- log保证了写磁盘的原子性
- 更新先写日志，后写磁盘
- 批量和并发带来了效率的提升


ext4 会同时写入datablock和commit block到日志区，磁盘无序的写入这些块。ext4在加入了一些校验码来保证datablock是否一同写入了日志区，而非只有commit块写入，datablock被crash掉了。


文件系统的写入方式
1. 日志方式，先写日志再写磁盘
2. ordered data:文件数据直接写入磁盘，只将inode等元数据放入日志

ext3的ordered data先写文件到磁盘，再commit 元数据。




