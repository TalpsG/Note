# os organization
## 宏内核
Unix linux xv6都是宏内核，完成了许多事情，进程调度，文件系统等等等等。
### 好处
1. 可移植，因为实现都是由os保证的。
2. 虚拟内存
3. 管理共享资源
4. 内核中的部分系统相互依赖，比如exec会调用文件系统的相关接口，宏内核实现起来较为简单

### 缺点
- 大，很多代码，结构复杂。
- 对于特定需求的主机来说，宏内核中的许多内容是不需要的。
- 由于宏内核内部实现问题，导致丧失了部分抽象能力，比如wait不可以等待与自己不相关的进程结束。
- 可扩展性差

## 微内核
微内核实现了IPC和线程，其他的东西都在内核外面实现。
比如文件系统就是一个内核之上的用户程序。各个用户程序借助内核实现IPC通信完成各自的工作。在一些嵌入式芯片当中微内核更有优势，因为这些芯片要实现的功能较为单一，不需要宏内核。

## 为什么要微内核
因为美.

- 微内核代码相对少，bug也就少，更安全
- 现实中存在被证明是安全的微内核系统。
- 容易被优化
- 小内核运行的快
- 设计的限制少
- 服务出错了重启就行，内核不会出现问题。kernel更加健壮
- 微内核上可以模拟或运行多个操作系统，这些os作为微内核之上的用户程序

挑战
- 目前没有研究指出哪些微内核的syscall是必要的。
- 需要用户程序例如文件系统等来扩展内核
- ipc太慢

## L4 微内核

L4 有7个syscall，13000多行代码，而且及其抽象。
在L4中Task对应了进程的概念，Task可以有多个线程，每个线程都有一个标识符。

- threadcreate
- IPC
- mapping
- 实现了设备驱动的用户程序可以直接访问硬件。
- 可以将设备中断转换为ipc
- page fault与对应的pager task有关。


## 提高IPC速度

一种方法是pipe的实现方法，很慢，两个进程多次系统调用进入多次内核，来实现。

L4的设计:
1. 同步的:p1调用send后直接等待p2调用recv,当p1p2都进入内核后，才会进行信息传输。这样不需要进行上下文切换就可以完成信息交互，不需要对数据缓存。
2. 对于小信息可以直接放在寄存器中，不需要进行拷贝。
3. 对于长信息。可以咋ipc中携带一个页面映射，接收进程可以访问对应的页面来进行数据交互
4. 对于RPC来说，可以结合send和recv. 将request 用send后立马recv来实现，减少内核切换的次数

ipc大致流程:
p1 send -> kernel -> 等待p2 recv或p2已经在内核recv了 -> 通信后返回p2 -> p2 send


## 在L4之上运行linux
为了生态，微内核系统必须要有一定的兼容性。在微内核之上运行Linux是实现兼容性的一个好办法。

将Linux内核作为一个Task运行，而Linux之上的进程也作为Task运行。
而传统的进入内核的syscall的方式被转化为IPC的方式，syscall代码会变为向Linux Kernel task发送消息，并等待返回。

在linux中，每个进程都会对应一个内核线程，而L4中由于Linux Kernel本身只是一个线程，所以linux进程对应的内核是线程是在kernel内部软件实现的，L4感知不到。

## L4的性能分析

结论就是L4性能和原生linux差不多。
