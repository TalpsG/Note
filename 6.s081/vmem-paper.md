# virtual mem primitives for user programs

## abstract
操作系统实现磁盘分页的虚拟内存的一种传统方法是使用MMU. 有些操作系统允许用户程序指定页面的保护等级(不可访问，读，写等),允许用户程序处理违反保护的行为,但是这些机制并不`robust`,也不有效,也不契合程序的需求

我们调查了几个使用了页面保护技术的用户级别的算法，分析了他们的共同特点,只为回答这个问题:操作系统应该提供什么虚拟内存原语给用户进程，现在的操作系统提供的有多好？

## intro

虚存的传统观点是通过只允许频繁访问地址空间的一个子集(这个子集存放在物理内存上)，来实现增大用户程序可见的地址空间大小。但是虚存的使用也有其他的目的。操作系统可以在进程间共享页面，设置指令空间为只读(保证了可重入性),设置部分空间为`zeroed-on-demand`或`copy-on-write`等. 实际上，有很多`tricks`可以被操作系统借助页面保护硬件实现.

现代操作系统允许用户程序实现这些`tricks`,通过用户程序提供违反保护的`handler`. 例如`Unix`允许用户进程指定一个特定程序在段错误信号生成的时候执行. 当一个程序访问超出虚存空间的内存时，用户提供的`signal handler`可以生成一个用户友好的错误信息去代替`segmentation fault:core dumped`.

上述的用户模式的`fault handler`是很危险的，因为这可能导致操作系统和硬件设计者相信不需要高效(原文就是`efficiently`)的进入用户模式的`fault handler`(一个例子就是优雅的错误，关机).但是用户模式的`fault handler`有很多有趣的应用. 这些应用极力的运用这页面保护和错误处理机制,也应该被操作系统实现者们理解.

这篇论文描述了几个利用页面保护技术的算法. 在许多例子中,这些算法可以使用传统的分页硬件来代替有时会用到的特殊的`microcode`.在共享内存的多处理器中，这些算法使用页面保护硬件来实现低开销的中等粒度的同步,避免了相当开销的同步指令序列.

我们已经测试了许多系统来分析当今的操作系统支持的用户级页面保护技术有多好. 最终从这些算法中我们在页面保护开销，内存映射机制的使用，TLB的拦截，页面大小和其他操作系统实现方面 吸取了许多教训.

## 虚存原语
接下来讲的每个算法都需要一些下面的操作系统提供的虚存服务:
1. `TRAP`:用户模式下的`page fault`
2. `PROT 1/N`:减少页面的可访问性
3. `UNPROT`:增加页面的可访问性
4. `DIRTY`:返回上次调用到这次调用之间的所有脏的页面
5. `MAP2`对一个物理页面映射到一个地址空间内的两个不同的虚存地址，处于不同的保护等级，

最终，有些算法可能会在页面小的时候更高效.

区分减少一个页面和减少多个页面的可访问性是有原因的. 修改多个页面的保护等级不一定就比修改一个页面的开销大很多. 我们讲的几个算法只能批量的修改页面的保护等级. 因此, 如果操作系统实现不能有效的降低单个页面可访问性,只能批量进行,则某些算法的性能会被牺牲.

我们不会为取消保护单个和多个页面制造差异，因为下面的算法没有同时取消许多页面。

有些多线程算法需要一个线程在其他线程在特定页面上出错的时候, 有权利访问这个特定的页面. 有许多方法解决这个问题, 一个简单高效的方法是 将这个页面在虚存上 多次映射, 一个地址是可访问的, 另外一个地址则会报错. 出于效率的原因, 这两个不同的虚拟地址应该在一张页表上,因此线程之间就不需要昂贵的页表上下文切换的开销了.

用户可以使用 `PROTN` `TRAP` `UNPROT` 来追踪脏页面. `DIRTY`设计为独立的原语是因为操作系统直接提供这个服务可能会很高效.

## 虚存应用

本节展示了一些样本，使用了虚存原语代替软件测试，特殊硬件或`microcode`.
页面保护硬件的高效性取决于访存时是否需要额外的指令. 我们通过调查的除了广泛的结论，关于什么是用户程序从操作系统和硬件中需要的.

### 并发垃圾回收

一个并发,实时的,`copying`的垃圾回收算法可以使用`page fault`机制去实现中等粒度的同步，在回收器和 修改线程. 页面机制提供的同步足够粗来保证效率，同时足够细来保证低延迟. 这个算法基于`Baker`的顺序的实时的`copying` 回收器算法.

