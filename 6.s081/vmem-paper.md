# virtual mem primitives for user programs

## abstract
操作系统实现磁盘分页的虚拟内存的一种传统方法是使用MMU. 有些操作系统允许用户程序指定页面的保护等级(不可访问，读，写等),允许用户程序处理违反保护的行为,但是这些机制并不`robust`,也不有效,也不契合程序的需求

我们调查了几个使用了页面保护技术的用户级别的算法，分析了他们的共同特点,只为回答这个问题:操作系统应该提供什么虚拟内存原语给用户进程，现在的操作系统提供的有多好？

## intro

虚存的传统观点是通过只允许频繁访问地址空间的一个子集(这个子集存放在物理内存上)，来实现增大用户程序可见的地址空间大小。但是虚存的使用也有其他的目的。操作系统可以在进程间共享页面，设置指令空间为只读(保证了可重入性),设置部分空间为`zeroed-on-demand`或`copy-on-write`等. 实际上，有很多`tricks`可以被操作系统借助页面保护硬件实现.

现代操作系统允许用户程序实现这些`tricks`,通过用户程序提供违反保护的`handler`. 例如`Unix`允许用户进程指定一个特定程序在段错误信号生成的时候执行. 当一个程序访问超出虚存空间的内存时，用户提供的`signal handler`可以生成一个用户友好的错误信息去代替`segmentation fault:core dumped`.

上述的用户模式的`fault handler`是很危险的，因为这可能导致操作系统和硬件设计者相信不需要高效(原文就是`efficiently`)的进入用户模式的`fault handler`(一个例子就是优雅的错误，关机).但是用户模式的`fault handler`有很多有趣的应用. 这些应用极力的运用这页面保护和错误处理机制,也应该被操作系统实现者们理解.

这篇论文描述了几个利用页面保护技术的算法. 在许多例子中,这些算法可以使用传统的分页硬件来代替有时会用到的特殊的`microcode`.在共享内存的多处理器中，这些算法使用页面保护硬件来实现低开销的中等粒度的同步,避免了相当开销的同步指令序列.

我们已经测试了许多系统来分析当今的操作系统支持的用户级页面保护技术有多好. 最终从这些算法中我们在页面保护开销，内存映射机制的使用，TLB的拦截，页面大小和其他操作系统实现方面 吸取了许多教训.

## 虚存原语
接下来讲的每个算法都需要一些下面的操作系统提供的虚存服务:
1. `TRAP`:用户模式下的`page fault`
2. `PROT 1/N`:减少页面的可访问性
3. `UNPROT`:增加页面的可访问性
4. `DIRTY`:返回上次调用到这次调用之间的所有脏的页面
5. `MAP2`对一个物理页面映射到一个地址空间内的两个不同的虚存地址，处于不同的保护等级，

最终，有些算法可能会在页面小的时候更高效.

区分减少一个页面和减少多个页面的可访问性是有原因的. 修改多个页面的保护等级不一定就比修改一个页面的开销大很多. 我们讲的几个算法只能批量的修改页面的保护等级. 因此, 如果操作系统实现不能有效的降低单个页面可访问性,只能批量进行,则某些算法的性能会被牺牲.

我们不会为取消保护单个和多个页面制造差异，因为下面的算法没有同时取消许多页面。

有些多线程算法需要一个线程在其他线程在特定页面上出错的时候, 有权利访问这个特定的页面. 有许多方法解决这个问题, 一个简单高效的方法是 将这个页面在虚存上 多次映射, 一个地址是可访问的, 另外一个地址则会报错. 出于效率的原因, 这两个不同的虚拟地址应该在一张页表上,因此线程之间就不需要昂贵的页表上下文切换的开销了.

用户可以使用 `PROTN` `TRAP` `UNPROT` 来追踪脏页面. `DIRTY`设计为独立的原语是因为操作系统直接提供这个服务可能会很高效.

## 虚存应用

本节展示了一些样本，使用了虚存原语代替软件测试，特殊硬件或`microcode`.
页面保护硬件的高效性取决于访存时是否需要额外的指令. 我们通过调查的除了广泛的结论，关于什么是用户程序从操作系统和硬件中需要的.

### 并发垃圾回收

一个并发,实时的,`copying`的垃圾回收算法可以使用`page fault`机制去实现中等粒度的同步，在回收器和 修改线程. 页面机制提供的同步足够粗来保证效率，同时足够细来保证低延迟. 这个算法基于`Baker`的顺序的实时的`copying` 回收器算法.

`Baker`的算法将内存的堆分为两块,`from` 和`to`. 回收的开始(`from`没地方了)，所有对象都在`from`上,`to`是空的. 从寄存器和全局的`roots`开始，回收器跟踪可以从`root`到达的对象图,复制每个可达的对象到`to`空间.指向`from`中对象的指针被`forwarded`到`to`空间中了通过将指针修改到`to`空间里的原来的对象. 有些`from`中的对象永远不会被搬走,因为没有指针指向他们,这些对象就是垃圾,需要被回收.

(`mutator`:修改对象间引用关系的程序.)

只要寄存器被`forwarded`，修改线程就可以继续执行. 当修改线程分配了新对象的时候,可达的对象会被增量式的从`from`中复制. 每次`mutator` 分配新对象(在`to`中),都会借助回收器从`from`中复制一些对象. `Baker`算法保持了以下的`Invariants`

- `mutator`在寄存器中只能看到`to`空间的指针
- 新对象只有`to`空间的指针,因为新对象是用寄存器初始化的.
- 在扫描过的区域中的对象只有`to`的指针
- 未扫描过的区域中的对象可以有两个空间的指针


~~我的理解~~:
`from`满了后把`root`和寄存器可达的对象都要搬走，但是寄存器只要被`forwarded`后,就可以执行`mutator`了,之后的对象搬运可以在新建对象时进行.


为了保证以上的`Invariants`,从对象中获得的指针必须检查是否指向`to`,不是就要从`from`搬运对象然后修改指针,之后才能把指针返还给`mutator`.这个检查可以用硬件支持有效的实现, 否则就要一些额外的指令来实现了. 且`mutator` 和 `collector`必须交替,他们不能真的并发执行,因为可能会同时复制一个对象到不同的地方. 

(通过`page fault`, 在回收开始后修改`mutator`对`from`区域的可访问性.)

并发的`collector`使用虚拟内存页面保护去探测`from`空间的内存引用，也使用该机制来同步`collector`和`mutator`. 为了实现同步, 算法设置了没有扫描过的区域的虚存为不可访问, 当访问该区域,会进入`page-access trap`. `collector` 处理这个`trap`然后扫描这个页上的对象,将对象引用的`from`中的对象复制到`to`,并更新指针.之后修改这个页为可以访问，重新执行出错的指令. 对于`Mutator`,页面只有`to`的指针,所以它也只能把`to`区域的指针给到寄存器.

`collector`与`mutator`并发执行, 扫描未扫描过的区域, `unprotect`扫描过的页面. 

这种算法需要`TRAP` `PROT` `UNPROT` `MAP2`. 我们需要对一个页面进行多次映射，这样可以让`collector`可以扫描页面但是`mutator`不行.


## 共享虚存
访问保护页面机制被用在实现网络中的虚存共享. 共享虚存的本质就是利用分页机制来保证一个读,多个写.


`SVM`系统有许多的处理器共享同一片虚拟内存. 虚拟内存被分为许多页面, 被标记为只读的页面存放在各个处理器的物理内存中, 但是正在被写的页面只能存在写处理器的物理内存中. 如果一个处理器想写一个在其他处理器上的页面,就必须先复制一份过来，然后告诉其他处理器我要写这个页面,你们的拷贝无效了. 各个处理器的内存映射管理器吧本地的内存当作共享虚存的缓存. 共享虚拟内存仅仅是虚拟出来,就像是操作系统使用的虚拟内存一样. 当处理器访问本地没有缓存的页面时，就会出现`page fault`, `Memory Mapping Manager`会从磁盘或者其他处理器的缓存中获得该页面. 


## 并发检查点
访问保护页面错误机制被成功的应用在实时的并发的检查点上. 这种算法使用在共享内存的多处理器上, 并发的与目标程序运行, 可以在很少的固定时间内中断目标程序,并且对目标程序和编译器是透明的。算法的效率是通用过使用分页机制允许检查点的费时间的操作可以与被检查的运行重叠起来.

开始时所有被检查的线程被停止。接下来，程序可写的内存区域被保存了起来。因为保存了足够的信息，所以这些线程可以被重新启动。最后，重启线程。

该算法可以避免一次性的保存内存到磁盘这段很长的等待时间,利用`page fault`。设置整个要保存的地址空间为只读，然后重启。负责保存的线程扫描地址空间然后进行搬运，复制完毕就修改页面为可读可写。

当用户线程读取只读页面时，运行速度和没有检查点是一样的. 如果进程写了还没被复制的页面, 则进入`page fault` ，复制线程立马复制该页面然后设置为可读写，重启线程.

在`benchmark`的测试结果中显示: 90%的检查点没有被中断超过一秒.


## `Generational` 垃圾回收

这种垃圾回收算法依赖于动态分配记录中的两个属性:
1. 年轻的记录比老的记录更容易死。
2. 年轻的记录通常指向老的记录。


属性1指出 垃圾回收器应该集中注意新的记录。 属性2提供了一种方式实现属性1的内容. 分配的记录会被保存在几个不同的区域，区域被称作`generations`.
一个代中的记录年龄是相仿的，新代的指针更可能指向老代。

老代指向新代的唯一方式就是对老代赋值，为了检测这种操作，每个对堆中对象的修改都必须能够被确定是否违反了属性2. 这种检查可以被特殊硬件或者编译器实现。幸运的是`LISP` `SMALLTALK`和一些相似的语言中非初始化的赋值语句很少,但是检查指令的开销能够占到运行时间的5-10%.

虚存硬件可以检测对旧对象的赋值. `collector`可以通过确定脏页来获得老代到新代的指针。


## Persistent stores 持久化存储
这是一种动态分配堆，在cpu核内，表现为一个磁盘映射到内存的文件。
运行在该cpu核上的进程都可以读写数据.因此需要`trap`等机制来进行一致性保证,实现数据类似的事务。



## extending addressability
没看懂

## data-compression paging
## heap overflow detection
堆溢出检测,xv6实现类似，增加哨兵虚拟页。


## VM primitive performance

本文讲的算法大致分为两类，一类是批量保护页然后通过`trap` 来`unprotect`单个页面。另一类是保护一个页面然后`unprotect`一个页面。

测


