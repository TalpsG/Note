# kernels and high level language
## why c
优点:
1. 对内存的控制力
2. 层级低，看c就可以想象出汇编
3. 直接访问内存
4. 极少的依赖


缺点:
很难写出安全的c代码


## hll in os kernel
优点
1. 类型安全
2. 有gc
3. 并发支持更友好
4. 抽象层级更高

缺点
1. 性能相对低:gc，运行时开销
2. 没有直接访问内存的能力
3. 不能集成汇编
4. 语言的并发模型和内核的并发模型并不类似



## go in kernel 
why go?
1. 静态编译的语言性能相对好
2. 容易调汇编，对并发支持好
3. 带gc

## biscuit
特性
1. 多核
2. 用户多线程
3. 比xv6更高性能的日志文件系统
4. 虚拟内存管理
5. TCPIP协议栈
6. 磁盘和网卡外设的驱动

用户程序
1. 有自己的页表
2. 用户空间和内核空间是硬件隔离的
3. 用户线程有对应的内核线程，系统调用就会进入内核线程，如果阻塞，就会调度同一空间的其他线程
4. 内核线程是goroutine


系统调用流程与xv6类似

挑战:
1. 要让goruntime 在裸机上运行，需要在裸机上模拟go runtime所需的特性
2. 使用go runtime中的调度器调度程序
3. 设备驱动:由于golang没有中断的概念，所以在驱动实现时需要小心，中断接受后向非中断程序发送标志，唤醒goroutine来处理。
4. 堆内存耗尽

## heap exhaustion
当堆内存满了，无法继续分配时，xv6可以返回一个错误码(malloc).但是go中的new永远可以成功。
解决方法
1. panic掉
2. 等待，可能会导致死锁
3. 没有内存就返回空指针，这样的话需要把之前分配过的内存也释放掉。

## solution
biscuit的解决方法是系统调用之前会执行一个reserve函数，这个函数会保留足够内存进行系统调用，如果不够就等待。由于没有使用锁等资源，所以可以在reserve中等待内核进行资源的释放。

如何计算系统调用需要的内存?
Go语言很容易做静态分析，分析代码来判断需要的内存。比如循环次数和递归次数，系统有一个固定的最大值以用于估计内存。内存分析也是有开销的。

## hll benefits
1. 内核采用大页
2. 有针对多核cpu的网卡队列


