# 多线程
## 线程概述

线程的状态:
1. pc
2. reg
3. stack


## 线程调度

对于计算密集型任务，cpu的定时中断会让他定期的让出cpu.

xv6的线程调度的实现是这样的
1. 在内核中强制将用户进程的cpu控制权给到内核
2. 内核会代表用户自愿被调度

## 线程切换
1. 进程trap进内核线程
2. 内核线程切换(yield,sched,swtch)
3. 内核线程返回用户进程

### 以定时中断举例

当定时中断发生，正在运行的进程A进入usertrap,调用yield,yield调用sched,保存了该进程上下文,切换至调度进程，调度进程执行scheduler swtch切换上下文会回到对应进程调用swtch的位置(对于进程A来说，如果调度回A则会回到sched的swtch的结束位置继续执行，返回sched和yield到usertrap,最后usertrapret回到用户区)

为什么swtch仅仅保存了部分寄存器？
答:因为rv的函数调用惯例中有部分寄存器是由调用方保存的，当返回函数时会由调用方恢复。
当切换进程时，由于切换了栈，所以返回时恢复的寄存器和切换过去的部分寄存器是配套的。

### 进程的创建与第一次运行
进程创建中allocproc 时拿到了新进程的锁，fork结束后释放了新进程的锁，然后等待该进程调度。当调度到新进程后，会先执行forkret函数(因为allocproc时将ra设置成forkret的地址了).forkret中释放了scheduler拿的该进程的锁，
