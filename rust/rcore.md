# 应用程序与基本执行环境

## 程序内存布局和编译流程
编译后的程序在运行时会被划分成`section`段，不同的段会被放在内存的不同位置。
一个程序只有一个`.text`代码段，而数据段则可以细化区分。
- 已初始化的全局数据存放在`.rodata`和`.data`，前者只读，后者存放可修改的数据
- 未初始化的全局数据存放在`bss`段，不占用elf中的空间，执行时直接在内存中进行零初始化。
- 堆区，运行时动态分配的内存，需要用户自己申请和释放。
- 栈，保存函数调用上下文

### 编译流程
1. 编译生成汇编
2. 汇编生成obj
3. 链接obj生成可执行文件

链接流程
1. 将多个obj的内存布局重新排布
2. 将符号替换成具体的地址
  - 在生成obj时，部分符号就已经被替换了，只有外部符号需要等到链接时替换。这些外部符号会被保存到符号表当中


编译好的可执行文件不能直接使用qemu运行，因为可执行文件中还有许多元数据，这些数据是qemu用不到的，且会导致代码和数据段被加载到错误的位置
程序的内存布局是由链接脚本决定的。
比如程序的入口地址，对齐方式，数据段地址，代码段地址等等等等。

### consolelog
`riscvsbi`中eid为1时，是调用输出字符的功能。
我们可以自己实现一个`Stdout`

```rust
impl Write for Stdout {
    fn write_str(&mut self, s: &str) -> core::fmt::Result {
        for c in s.chars() {
            sbi::console_putchar(c as usize);
        }
        Ok(())
    }
}
```
为`stdout`实现了`write`后，可以调用`stdout`的`write_fmt`方法，该方法中调用了`write`方法，最终调用我们写的`write_str`.


# 批处理
## 用户程序与特权级
批处理系统运行用户程序是一个接一个运行的。
系统内核运行在`smode`通过`sret`来跳转到用户程序处,同时用户程序通过`ecall`返回操作系统内核.

用户程序经过了一个`start`函数包装，`start`在`0x80400000`处，先清理栈，设置`main`的参数，然后调用用户程序的`main`函数，最后调用`exit`回到内核态。
`sys_exit`中读取下一个任务并执行

