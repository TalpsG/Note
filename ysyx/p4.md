# from c to binary program
## 预处理

### 头文件是如何找到的
`gcc -E a.c --verbose > /dev/null`

通过`man gcc`搜索`-I`去查看头文件的搜索顺序

1. 文本替换
2. 去掉注释
3. 连接`\``拆分的代码行
4. 处理条件编译`ifdef`等
5. 字符串化 `#` 
6. 标识符连接 `##`

## 编译
词法分析->语法分析->语义分析->中间代码->优化->目标代码

词法分析:token
语法分析:ast
语义分析:确定表达式的类型，报告语义错误
中间代码生成(intermediate representation):面向编译的指令集
优化:两个状态机在某种意义上相同，可以用简单的替代复杂的
- 相同:程序的可观测行为一致性
    - 对volatile变量的访问严格执行
    - 写入文件的数据需要严格执行
    - 交互式设备输入输出要严格执行
目标代码:中间代码ir状态机翻译为处理器isa状态机
- `%1，%2...`->`<R,M>`
- `alloca,store....`->`ISA指令`


静态程序分析:分析ast中的信息，可以检查出语法错误，代码风格以及一些漏洞。

## 汇编
`objdump -d a.o`


## 链接
crt=C runtime c运行时环境

printf代码在哪里？
在动态库中，运行时链接。

## 执行

谁来把可执行文件加载到内存，并跳转到程序执行的？
运行时环境，宿主操作系统/QEMU

### 定义行为与ABI
```c
int main(){
    printf(6-2147483648>6?"T":"F");
    printf(6-0x80000000>6?"T":"F");
    return 0;
}
```

该代码在32位与64位的c90与c99标准下的执行结果不同

-2147483648 在32和64位与c90和c99标准下的类型不一样
     32bit            64bit
c90  unsigned long    long
c99  long long        long 

-214748368如何被判断类型，选取第一个可以被存入的类型
c90: int,long,unsigned long.
c99: int,long,long long.

C标准如何定义的数据长度？
仅仅定义了数据类型的最小长度，为了可移植性，以及考虑到将来的计算机系统。

### 未指定行为
c标准对某些行为提供了多种方式，具体实现需要选择。
比如函数调用参数求值的顺序是未指定的。
重新编译程序可能得到不同的结果。

### 实现定义行为
一类特殊的未指定行为，具体实现要写到文档里，在指定的环境下执行的结果一样。

### 未定义行为
不知道会发生什么
比如缓冲区溢出
```c
int a[2] = {0};
printf("%d",a[2]);
```

c99中对实现的定义：
编译器+执行环境(处理器+os+运行库)
三者需要对实现定义的行为达成一致

### ABI
软硬件共同的协定
- 处理器的指令集，寄存器结构等
- 数据类型大小布局，对齐等
- 参数调用约定，返回值约定
- 运行库，目标文件格式等
- 等


如何在跨平台的条件下使用特定长度的数据类型
`int8_t a = value;`

x86 的char是signed,而riscv的char是unsigned
