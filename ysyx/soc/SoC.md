# SoC
ROM UART flash SDRAM
## 最简单的SoC
crossbar(Xbar)
cpu发送访存请求给Xbar,Xbar将请求转发给不同的设备，其功能类似于译码器，但是要求有发送错误信号的能力。
可以将arbiter和Xbar组合成多进多出的Xbar,也称总线桥、interconnect，他链接多个master和slave,由arbiter确定将请求发送到对应的slave.
```ascii
+-----+       +---------+       +------+       +-----+
| IFU | ----> |         |       |      | ----> | UART|   [0x1000_0000, 0x1000_0fff)
+-----+       |         |       |      |       +-----+
              | Arbiter | ----> | Xbar |
+-----+       |         |       |      |       +-----+
| LSU | ----> |         |       |      | ----> | ROM |   [0x3000_0000, 0x3fff_ffff)
+-----+       +---------+       +------+       +-----+
```

### 可能发生的问题
- IFU实际上可以访问UART，也就是可以从UART中取指令
- 访问设备寄存器的长度问题：axilite并没有读取长度的信号，但是读取长度会影响到设备寄存器的状态，需要引入完整的AXI总线来解决该问题。

## 更实用的SoC
flash：
flash存储单元分为许多block,block又分为许多sector(扇区)，扇区有可以分为许多个page。

flash颗粒不能直接写入，为了支持store指令，需要SDRAM来当作存储器。
SDRAM最开始处于idle,当不需要刷新时，sdram查看访存请求读则接受请求等待访问完毕后返回idle状态。

从flash中加载程序：
flash不可以直接写，可读。sdram可读可写。
1. 将flash中的程序链接到sdram的地址空间，并且将栈指针分配到该空间。
2. 需要编写一个加载器，用于将flash的程序搬到sdram中。加载器可以是二进制加载器，也可以是elf加载器，无需拷贝bss段，直接用memset初始化bss段即可。**加载器程序的栈也要在sdram地址空间中，且不可以覆盖要加载的程序所占的空间，加载完成后就可以释放该空间**
3. 第三步就要将加载的程序放在数据段中，从而使加载器可以找到并且加载程序
4. 将加载器链接到flash的地址空间中并且烧写进flash.
5. 最后调整cpu复位的地址，指向flash中的加载器起始地址
6. cpu复位执行加载器


## 中断系统
CLINT定时中断
PLIC外部中断

### CLINT
clint包含三个寄存器
mtime可读可写恒定速率增加
mtimecmp 可读可写，用于定时，当mtime >mtimecmp的时候产生M模式的时钟中断
msip 可读可写，可以写入1出发M模式的软件中断

上述寄存器需要基于总线实现(~~因为clint算外设么？~~)

#### cpu中断响应过程
M模式的时钟中断为例
mstatus.MIE位为1,代表cpu全局中断使能
mie.MTIP 为1 ，代表M模式时钟中断使能
mip.MTIP 为1 代表M模式时钟中断等待为为1，当mtime>mtimecmp时产生中断并且clear该位

riscv还有一个委托机制，可以将一场或者中断委托给S模式处理，运行os需要使用该机制

## 其他
### DMA
专门进行数据传输的通道，传输时不占用cpu，本质上是一个axilite,通过状态机控制总线信号进行读写

### AXI跨片通信
如果直接把axi总线所需的信号全部连接到外部，则引脚太多了，成本高。
可以使用一个叫做chiplink的协议：把数据用较少的引脚打包发送，对方接收到数据再解包。
