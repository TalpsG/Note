# 隔离级别
1. 可并行化的
2. 可重复读
3. 读已提交
4. 读未提交

# mvcc 多版本并发控制
mvcc就是对逻辑对象保存多个物理版本。
当事务写数据时，创建一个新的对应数据版本。
读数据时会读取该事务开始时最新的数据版本。

思想就是
- 写不阻塞读
- 读不阻塞写

使用时间戳来确定版本的可见性。
t时刻的事务可以见到t时刻之前提交的数据版本。
通过mvcc可以很容易的实现"时间旅行"


`snapshot`隔离级别：
事务可见在其之前提交的数据
当两个事务要更新同一条数据时，第一个事务会胜出，第二个事务需阻塞或者自杀。


mvcc需要搭配之前提到的并发控制协议一起使用。

1. TO
2. OCC
3. 2PL

## 版本存储
dbms会在tuple中添加一个指针字段，指向不同版本的数据

版本存储的方式
1. 追加
  - 各个版本数据都存放在原来的表中，使用指针字段相互连接，形成链表
2. 时间旅行存储
  - tuple后指针指向一张新表，新表中存放所有版本的数据,新表中也有一个指针字段指向其他版本的数据，形成链表
3. delta存储
  - 也是指针指向一张新表，但是新表中存储的是新版本相对于现在版本的增量，因此想要回溯到之前版本时需要根据增量一条一条的修改原数据直到对应版本处。


## 垃圾回收
当
1. 没有事务可见该版本
2. 版本被自杀的事务创建
时，该版本应该被回收。

- tuple level
  - 扫描tuple找到最老的版本进行回收
- txn level
  - 事务跟踪他们最老的版本，dbms无需扫描tuple
  - txn维护自己的writeset和readset,在自杀和commit时，提供信息给vacuuming worker。由vacuuming worker来负责判断何时回收。

- 后台vacuuming
  - 后台有gc线程负责gc
- cooperative cleaning
  - 在执行事务查询数据版本时捎带手进行垃圾回收


## 索引管理
索引维护也会因为mvcc变得复杂起来。
主键索引可以指向version chain的头，当创建新版本时才进行更新主键索引。

当主键的属性被修改，则被当作删除后插入处理。


副键索引更加复杂。
我们还要考虑索引使用的是逻辑指针还是物理指针.
逻辑指针：使用固定长度的标识符标志tuple,需要经过一个转换才能到rid

物理指针:直接使用version chain的物理地址

mvcc的数据库通常不存储与key相关的版本信息。
每个索引都要支持多重key，因为不同的版本中相同的key可能会指向不同的tuple


由于mvcc的多版本，在查找数据是可能找到多个版本的相同key的tuple,我们需要编写额外的逻辑去找到正确的版本。


## mvcc 删除
tuple被删除后，插入相同值的tuple在mvcc下可能会被认为是原tuple的新版本，我们需要一些手段来表示tuple被删除。


deleteflag
在每个版本的数据后加一个删除标识位。

tombstone tuple
存放一个墓碑tuple，在这个版本tuple前的版本都被删除了。
