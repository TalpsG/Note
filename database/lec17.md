# 时间戳顺序
使用时间戳的方法来确定是否当前并发事务是可串行化的。

时间戳的分配分为三种
1. 系统时钟
2. 逻辑计数
  - 分布式数据库中很难同步
3. 混合方式

# TO协议
在使用时间戳顺序的方式下，事务的读写是无锁的。

每条数据都有读写两个时间戳。
在事务读数据时，是不可以读取未来修改过的数据的(即写时间戳比本事务的时间戳还新的数据),出现这种情况时自杀重新执行该事务。 读取数据后会更新该数据的读时间戳。 将数据拷贝到本地，以便以后继续读。



写数据时，是不可以写入未来读取和修改过的数据的。
写入数据后修改写时间戳，将写入的数据拷贝到本地以便可以重复读取。

## 托马斯优化
当写入数据时发现写入的是未来修改过的数据，此时可以允许事务继续执行。将本事务要写入的数据写在本地，此后读取该数据时从本地读取，假装修改过即可。

因为本事务以及未来的事务都会修改该条数据，因此我们假装修改过就可以了，反正以后也要修改。


## observation
TO在事务很长的情况下可能会导致事务的饥饿。
如果使用场景中冲突很少，且事务都比较短，TO规则会有一些不必要的时间戳开销。

优化的方向是优化没有冲突的那部分。


# optimistic concurrent control
occ也是使用时间戳的并发控制规则,只不过只使用一个时间戳。
occ为每个事务提供一块区域存放读取和写入的数据。
当事务提交时，dbms会比较并发事务本地的数据是否有冲突，没有则会写入数据库。


occ分为三个阶段
1. 读阶段
  - 读取和写入数据，数据存放在事务本地
2. 验证阶段
  - 验证阶段检查事务是否在冲突
  - **时间戳在该阶段分配给事务**
3. 写阶段
  - 将修改写入数据库，如果冲突则自杀，重启事务。

读阶段:
dbms将事务要访问的所有数据都存到事务本地。

验证阶段:
当事务`commit`，dmbs会检查并发事务是否冲突。
- 是否是可串行化的
- rw和ww冲突是否是单向的

检查的方式有两种
1. 向回检查
检查已经提交的事务和当前事务是否存在冲突，如果存在，需要自杀重启。
2. 向前检查
检查当前还没有提交的事务和本事务是否有冲突，此时冲突，则自杀的事务根据数据库实现而定。


向前检查时，如果`t1< t2`则分为三种情况
1. 已经是串行化的了，这种就没有冲突
2. 如果t1在t2开始写阶段进入验证阶段，此时要检查t1写的数据是否有t2读的，如果有则冲突需要自杀。
3. t1事务先进入验证阶段，t2事务后进入，则需要判断
  - 如果t1没有写过任何被t2访问过的数据，则无冲突
  - 否则需要自杀

occ的写入阶段有两种方式执行
1. 串行提交：用一把大锁锁住整张表，然后进行更新，`THE WORLD`
2. 并行提交:用细粒度的锁支持并行的验证和写入阶段

## occ observation
在 只读事务多且事务访问不相邻的数据时，效率很高。

但是多了很多拷贝的开销。验证和写入阶段是瓶颈。
自杀时的开销很大，因为是在写入阶段才自杀的。


# 隔离级别
幻读: 一个事务中读取max后其他事务insert了一条，本事务再次读取max变了就是幻读

解决幻读的方法
1. 重复扫描
2. 谓词锁
3. 索引锁

## 重复扫描
第一次扫描时记录一些信息，用来保证后面的扫描只扫描到符合事务一致性的数据。

## 谓词锁
对select的where上共享锁，对insert update 和delete的where上排他锁。
这样在查询时，insert等数据更新的语句是无法获得锁的。

## 索引锁
索引锁分为很多
kv锁，间隙锁，key range锁，以及等级锁

kv锁就是简单的锁索引中的一个叶子节点中的数据。

间隙锁是锁住索引叶子节点间的间隙。比如获取了max,则间隙锁对最大的k上间隙锁，从该k到正无穷都无法修改插入删除。

key range锁范围锁，对于一些不存在的value需要虚key.

等级锁，可以对不同层级的数据使用不同层级的锁。
