# 两段锁协议
为了保证日程的结果是正确的，我们必须采取某种措施。
## 上锁
锁分为共享锁和独占锁

锁的管理是由lock manager来进行的。事务去申请和释放锁。

两段锁协议决定了事务能否访问数据库内的部分数据.

## 两段锁协议
事务中分为两个阶段：
- 第一个阶段只能上锁，不能解锁
- 第二个阶段只解锁不上锁


但是这回带来一个问题，当事务回滚的时候，可能会连带着其他并发的事务一起回滚，比如:
a事务做了某些操作后解锁最后回滚，b事务在回滚前获取了a事务的一些修改后的数据，a回滚后b事务使用了脏的数据。

为了解决级联回滚的问题，我们可以使用`SS2PL`
- 事务中只能上锁不能解锁
- 提交事务前全部解锁


回滚事务时要滚多远？
1. 整个回滚
2. 部分回滚，有保存点
但是`SS2PL`可能会导致死锁的问题

## 死锁检测
dbms维护一个依赖等待图，根据图检测死锁，如果检测到会按照一定策略回滚某个事务。
会按照一定指标给事务设置优先级,根据优先级选取牺牲的事务
- 按时间戳
- 按进度
- 按已经上锁的数据对象个数
- 按事务已经重启了次数


## 死锁预防
当事务要获取一个别的事务已经拿到的锁时，会按照一定的策略杀死某个事务
1. 老的要小的的锁，会等待.小的要老的会直接自杀
2. 小的要老的会等待。老的要小的，会把小的杀掉

## 意向锁
意向锁其实不是锁，而是标记
- is 表示该数据层级以下的数据有被读取的
- ix 表示该数据层级以下的有被写入的
- six 表示该数据层级的所有数据被读取，且又被写入的

我们对该数据层级上意向锁后还是有对下层的具体数据上读写锁的。
