# processing model

## 连表算法
1. 嵌套循环
  - 块循环
  - 索引循环
2. 排序归并连接
3. 哈希连接
## query plan
1. 迭代器模型
2. 物化模型
3. 向量模型
### 迭代器模型
查询语句是由算子组成的一棵树
每个算子实现自己的`next`方法，父算子调用子算子的`next`方法来获取算子的下一条结果。

查询处理类似流水线，算子一条一条向上传递数据。

在某些算子处必须阻塞，比如连表，子查询，排序处，必须要将子算子的所有结果都拿到且处理完毕才可以向上传递


### 物化模型 materialization model
每个算子一次处理全部输入，然后输出全部输出

适用于`OLTP`，小批量的查询或更新。

### 向量模型
前两者的结合，算子实现`next`，每次返回一批结果.
对`OLAP`较好，因为减少了函数的调用次数，且有可能被处理器的`simd`指令优化

## 计划处理方向

从上到下，从根节点将数据从孩子处拉上来，常常传递`tuple`为数据

从下向上，从叶子节点将数据推上父节点，允许更严格的cache和寄存器控制
从下往上也可以进行更多运行时的优化


## 访问方法
dbms如何访问表中的数据？
1. 顺序扫描
  - 数据skipping 优化
    - zone map:在某个地方记录页内数据的一些统计信息比如最大值最小值等，然后查数据先查zonemap.
    - 大约查询，查询表中的子集，给出一个大约的结果
2. 索引
3. 多索引


## 修改数据的查询
`insert update delete`修改表后需要维护索引

修改的算子需要记录被修改过的数据,否则可能会出现一条数据被修改了多次的情况


`update/delete`:
- 子算子传递`rowid`
- 必须记录最近修改的`tuple`

`insert`有两种选择
1. 在`insert`算子内物化`tuple`并插入
2. `insert`算子直接插入由子算子传递上来的`tuple`

## 表达式求值
表达式会生成一棵树，然后根据树来求表达式的值。





