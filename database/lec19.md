# log
恢复算法包括两部分
1. 事务的恢复
2. 保证一致性原子性和持久性的恢复

崩溃分为三种
1. 事务崩溃
2. 系统崩溃
3. 存储介质崩溃

**事务崩溃**
逻辑错误，比如并发事务无法串行化导致的自杀。

内部状态错误，比如死锁

**系统崩溃**
软件错误，比如软件中的bug
硬件错误，比如电脑关机导致的内存上的内容丢失

**存储介质崩溃**
磁盘损坏。
数据库设计者不需要考虑该问题。

数据库必须保证实现以下两点
1. 事务提交后必须是持久的
2. 持久化修改保证原子性一致性

**redo undo**
redo是重做，undo是撤销，在数据库崩溃后恢复是需要使用到这两个操作

## bufferpool 策略
写回页面的修改策略
1. steal 一次写回一页，即使当前页面上有没有提交事务的修改
2. nosteal 写回的页面仅仅包含提交的修改
写回策略
1. 每次事务提交强制写回
2. 不强制

组合 nosteal+force
- 最容易实现，每次都将提交的事务写回磁盘。
- 但是需要所有的修改都存放到物理内存中，可能会出现内存存不下的问题
- 经常写磁盘，开销大

steal + noforce
- 恢复时需要撤销和重做
- 写磁盘的开销少


## shadowpaging 影子页
dbms将要修改的页面复制到内存并存储两个版本.
1. master 只读
2. shadow 提供给事务修改

事务提交后，将修改后的shadow页写回磁盘，并且将该shadow页面当作master。


缺点
1. 复制整个表开销很大
2. 提交的开销也很大
3. 磁盘空间容易产生碎片
4. 需要垃圾回收
5. 同时仅支持一个写者事务或者一批事务(因此采用nosteal + force)


## WAL
写前日志,使用 steal + noforce
类似xv6的日志层，在事务执行时维护一个logfile,记录对数据的修改。提交事务时将logfile写入磁盘的日志区。一旦logfile写入磁盘，事务提交就完成了. 如果此时发生故障，重启数据库后，dbms可以通过日志区的logfile来恢复数据库的内容.

具体何时将日志写到数据库中则视数据库具体实现而定.

在日志中有
1. 事务id
2. 数据对象id
3. 修改前的值(用于撤销)
4. 修改后的值(用于重做)


logfile频繁写入磁盘可能会是性能的瓶颈，可以采用组提交的方式，等待一组事务提交到logfile后再写磁盘。不过组提交会导致数据库故障丢失多次提交。


## logging schemes
日志记录的格式
1. 物理记录，记录数据的在某个页某个偏移的二进制变化
2. 逻辑记录，记录sql语句
3. 物理逻辑记录，记录某个pageid slotid位置的二进制变化


逻辑记录会存放更少的数据，但是某些情况下很难实现逻辑记录，比如向某个字段写入当前时间。

## 日志结构的系统
日志结构的数据库系统没有脏页，每一个从磁盘取的页面都是不可变的。
dbms在内存上记录日志，日志满了就将日志写回磁盘。

即使是日志结构的db也需要使用wal作为崩溃后的数据恢复手段。


## 检查点
如果不加限制wal会一直增长，但我们的日志区并不是无限大的。
dbms会周期性的设置检查点，检查点前的日志会被写到磁盘。

在设置检查点的时候会
- 暂停查询
- 写日志到磁盘
- 写回bufferpool中所有修改的页面
- 在日志中写回检查点的信息
- 继续执行查询


恢复数据库时，所有在检查点前提交的事务都会被忽略。检查点后提交的事务需要`redo`重做，日志中未提交的事务需要`undo`撤销。

## 检查点带来的挑战
1. 检查点会暂停当前所有查询，下一节课讨论这个问题
2. 扫描所有未提交事务会耗费很多时间，下节课会讨论加速
3. 检查点要多久设置一次？
  - 太频繁开销很大
  - 太不频繁会导致检查点很大，停机时间长，恢复的时间也长
