# 数据存储

`tuple-oriented` 的方式会浪费一些空间，页面当中会存在一些细小的碎片。
`useless io` 更新一个`tuple`需要读取整个页面
随机的`io` 一次更新多个不同页面的`tuple`会导致需要读取不同的页面然后写回

### log-structured
日志结构的存储实际上存储的是对`tuple`的修改。每一条日志都代表了一个对`tuple`的修改操作。

日志会按顺序存放在`buffer`里，满了之后写回到数据库中，有点类似`xv6`文件系统的日志层。

**日志写回到磁盘，但是还没有按照日志修改对应的磁盘数据。也类似`xv6`，在某个时间点会按照日志更新数据库数据**

老师说写回的日志访问的都是一个页面上的数据，我个人感觉是一个页面一个日志`buffer`？

日志结构使得写操作的速度变快了(因为写操作满`buffer`才会执行)

读取会变慢一些：我们从日志页倒着查找，如果有对应数据修改的日志，那么就直接查到了。否则需要磁盘读取。

加索引的方式可以改善读取的问题：
`tuple id`有指向本修改了数据`tuple`的日志或存放在磁盘的位置。


日志可以进行周期性的压缩，我们只需要保留相同数据最新的日志条目即可。对于删除的日志，我们可以删除对应`tuple`的索引，这样也就不需要存储删除的日志了。

日志页压缩过后，只剩下了`put`操作，每一个`tuple id`只会出现一次.
因此，我们不关心日志条目的顺序，只需要按`id`排序就可以了，这样会让我们的查找速度加快。

### log的问题
1. 更新一条数据可能伴随着多次的磁盘读写.
2. 压缩日志的代价不小

## index-organized
存储索引用来根据`record id`获取数据

索引可能类似树的形状，在叶子节点存放实际数据页面(`slotted page`)

索引树是有序的，因此查找的效率较高

## tuple layout
一条数据会有一个`header`用来记录比如每个字段的长度之类的信息。

类似结构体对齐，`tuple`数据也要存在对齐。
可以使用类似结构体的方式，填充数据来对齐8Byte,也可以进行重排数据来满足对齐的要求。


### 数据类型
数据库中的浮点数整数和`c++`的一样，依靠`ISA`的支持可以加快数据的处理速度。
但是机器支持的数据精度优先，比如`IEEE-754`的浮点数。

因此数据库会实现定点数来保证数据正确性


`NULL`:
- `tuple`的`header`存放一个位图来表示哪个字段是`NULL`
- 指定一个特殊值当作`NULL`
- 在每一个属性值前存一个`flag`指示这个值是否为`NULL`(浪费空间)


对于很大的数据类型(`varchar`)，数据不会直接存放在`tuple`页面内,而是存放其指针。

数据本身会存放在单独的页面中(`overflow page`)
可以采用链表的方式存放大型数据，`tuple`内的指针指向第一个溢出页，每一个溢出页都有指向下一个页面的指针

### 外部存储
有些数据库可以存放外部文件，但是数据库仅仅做存取，无法修改文件。